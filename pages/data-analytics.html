<html>
<head>
    <link rel="stylesheet" href="../styles.css"></link>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body data-tags="analytics; mentoring">
    <header>
        <title>Compilation of what I've learned about analytics</title>
    </header>

    <div class="main-bar">
    <h1>Analytics: my learnings</h1>
    <p>Return to <a href="../index.html">home</a>.</p>

    <h2>Readings</h2>
    <p>Articles that've stood out to me, or that I'd like to revisit:</p>
    <ul>
        <li><a href="https://benn.substack.com/p/the-rise-of-the-analytics-pretendgineer">The rise of the analytics pretengineer</a>, by benn.substack</li>
    </ul>
    <p>Useful concepts:</p>
    <ul>
        <li><a href="https://www.macrometa.com/articles/what-is-the-difference-between-operational-data-and-transactional-data">Transactional vs operational data</a></li>
    </ul>
    <p>Books I'm reading, in varying degrees of completion:</p>
    <ul>
        <li>Fundamentals of Data Engineering, by Joe Reis and Matt Housley</li>
        <li>The Data Warehouse Toolkit, 3rd Edition, by Ralph Kimball & Margy Ross</li>
    </ul>

    <h2>Learnings</h2>

    <h3>Explaining git to the layperson</h3>
    <p>In 2024, I've had to explain how git works to a couple of people who don't know what it is, and this explanation seems to have worked:</p>

    <h4>Grasping versioning and collaboration using the GDrive analogy</h4>

    <p>You know Google Drive? A git repository is like a Google Drive folder:</p>
    <ul>
        <li>You can create and store google docs, google sheets, and subfolders in it, as well as zipped files, text files, csv files, etc.</li>
        <li>You can see the past versions of the documents and folders. In the version history, you can see what's been added or removed, as well as revert back to previous versions if you don't like the new changes.</li>
        <li>You can share them with people, collaborate with them within the Drive, and give different collaborators different levels of access, making it either private or public, and you can work within the folder in real time, with collaborators editing different parts of it simultaneously.</li>
    </ul>
    <p>So a git repo's like a Google Drive, but for code.</p>
    <p>At this point, I ask them if they get the analogy and if they have questions. Once we clarify the latter, I guide them through setting up their IDE and cloning a repository (if there's an existing one they can work on) or creating a new git repository for a project. The idea's to ensure they have the tools to practice while they learn. It's fine if they don't get the meaning of <code>git clone</code> or <code>git init</code> or the exact process behind these commands yet, but it's important they know they can return to that later.</p>
    <p>If it's an existing repository, I walk them through its file structure in their IDE. If we're using GitHub, I walk them through the same thing there. If there's a particular file I want them to work on after this, I explain what it does and what's missing from it. Ideally it's a simple improvement that needs to be made, e.g. editing a couple of lines of code. Here, I want them to see the similarities between the files they have in their local computer and the files in GitHub.</p>
    
    <h4>Grasping branches using the tree analogy</h4>

    <p>Now, I have the option to talk about branches. If the repository they're working on already uses branching and collaborators need to make pull requests, then I find this a good time to bring up the concept, lest it gets confusing later on. If it's their new personal repository where there's little likelihood of conflict should they pull from and push to main, then I could save the topic of branches and pull requests for later.</p>
    <p>To introduce branches and PRs, I pull out a diagram (adapted from <a href="https://www.nobledesktop.com/learn/git/git-branches">noble desktop</a>):</p>
    <img src="images/git-branches-merge.png" alt="A diagram of a git master branch with two child branches extending from it and merging back into it at different points in time">
    <p>Imagine a tree. It has a trunk, out of which grow branches. That trunk, the main branch, is what you're seeing here: it contains code and files that produce the website you're seeing now or that produce whatever the files are telling the computer to produce (kinda). If you're using Visual Studio Code as the IDE, you can tell what branch you're on by looking for the branch's name on the bottom left of the editor. You can also open your terminal and enter the command <code>git branch</code>; the asterik next to the branch name is, well, where you're at.</p>
    <p>Let's say you want to add a new feature to the site, or submit a change to the main branch. Enter <code>git checkout -b yourbranch</code> in the terminal, and see how the name of the branch changes in the IDE, and how the asterik appears next to your new branch when you enter <code>git branch</code> again. You're now on a little branch coming out of the main trunk, and this little branch is called <code>yourbranch</code>. With the new branch created, you can switch between <code>main</code> and <code>yourbranch</code> by using <code>git checkout main</code> and <code>git checkout yourbranch</code> respectively.</p>
    <p>It's here that I introduce them to <a href="https://git-scm.com/docs/git">git's documentation</a> and tell them about the <code>-b</code> flag they used earlier and why they didn't have to include it when switching between branches. I want them to get into the habit of referring to documentation.</p>
    <p>Then I explain: You can play around with this branch as much as you like, without worrying about doing something that'd cause the main branch to go wonky. You also don't have to worry about someone else also playing around with the same set of code and overwriting your own in the same playground (yet), because they can make a new branch of their own, too. Eventually, once you're done with your edits, you want to request your fellow collaborators to review your work.</p>
    <p> We call this raising a pull request. The aim of it is to get your collaborators to check through your code, and if they're okay with it, they'll approve it. That's when you can merge <code>yourbranch</code> into <code>main</code>.</p>
    <p>I stop here for a clarity check: do they have any questions?</p>

    <h4>Grasping the git workflow by making their first pull request</h4>
    
    <p>Enough of high-level explanations; it's time to make those edits. I watch them do it in <code>yourbranch</code>, save it, and then I pull out a diagram (adapted from <a href="https://www.freecodecamp.org/news/learn-the-basics-of-git-in-under-10-minutes-da548267cc91">freecodecamp</a>):</p>
    <img src="images/git-workflow-diagram.png" alt="A black and white diagram of git commands like git add, commit, push, merge, fetch and pull, and how they work">
    <p>I point to the working directory. "Your changes are here now," I tell them, "and your aim is to get them ready for a pull request by your collaborators. So you'll need to get your changes to here instead," and I point to the remote repository (main). I open up GitHub and navigate to the repository. "Once you do that, you'll see your changes reflected here."</p>
    <p>Here, it gets a bit messy, but I try to tie my explanations back to previous analogies, while introducing new commands:</p>
    <p><strong>Figure out where you are with <code>git status</code></strong>: Enter <code>git status</code> in the terminal and read to me what the output says. It should indicate we're on <code>yourbranch</code> and that there are untracked files. "Use <code>git add</code> to include in what will be committed," it writes, so try that command and enter <code>git status</code> again.</p>
    <p><strong><code>git add</code> to the staging area</strong>: See those green lines? They're the files you just added, and you've added them to what we call the staging area. This is where I make reference to the diagram. Then, I tell them to make more changes to a file they just added, small ones, like changing a comment or a piece of copy.</p>
    <p>Enter <code>git status</code> again and note how the filename reappears in the outputted red text, under the section that writes, "Changes not staged for commit (use <code>git add</code> or use <code>git restore</code>)". You can <code>git add</code> that file once again to the staging area, or maybe you don't like that new change, and you can enter <code>git restore</code>. This staging area is your playground; you can add or remove things from it however you like.</p>
    <p><strong>Check the version history with <code>git log</code></strong>: Remember how a git repository is like a Google Drive folder? Just like how you can view the version history of your google doc, you can do the same with your files using <code>git log</code>. There shouldn't be anything of note there yet, except for the output to tell you that <code>HEAD -> yourbranch, origin/main</code>. Type <code>q</code> in the terminal to stop printing out the logs.</p>
    <p><strong><code>git commit</code> to the local repository</strong>: Once you've amended a bunch of files and you're ready to commit to your changes, enter <code>git commit -m "a message about your changes"</code> in the terminal. Now you can type <code>git log</code> again and read the different output. You can continue making a bunch of edits, and you can add all the edits related to some same task (e.g. remove comments from all files) to the staging area, upon which you can commit them to your local repository using <code>git commit</code> and a useful message.</p>
    <p><strong>Publish <code>yourbranch</code> as a remote repository and <code>git push</code> to it</strong>: Once you've gathered all your edits around some central theme (e.g. build a new feature on a website) and tested it, and you're ready to get it reviewed by your collaborators, enter <code>git push</code> in your terminal. The first time you do this, it's not going to work, and here I tell them to not freak out at it not working, and instead, read the terminal's output. Run the command as it says to publish the branch, and it's going to net you a link to a pull request that you can open.</p>
    <p><strong>Open a pull request</strong>: The main things I explain here, after following the link, are the request review button and the fact that you can tag collaborators in your comments.</p>
    <p><strong>Approved? Merge it to the main remote repository</strong>: Get them to press merge to main. They'll see their changes show up in the remote repository, and it's here that it's quite nice to watch them go, "Oh!" when they see that.</p>
    <p><strong><code>git checkout</code> to <code>main</code> and <code>git pull</code></strong>: To close the loop, have them return to their <code>main</code> branch in their terminal, and merge/pull the changes they just made in <code>yourbranch</code> from either the local repository (assuming it's up to date and no other collaborator has pushed and merge changes of their own to <code>main</code>) or the remote repository.</p>

    <p>It's still a lot to take in, but the main points that helped me explain these concepts live and that I want to stress are:</p>
    <ol>
        <li>Emphasising they should reference documentation and online guides when they're stuck</li>
        <li>Getting them to practise relaxing and reading the terminal's output; don't panic at the sight of errors</li>
        <li>Draw simple diagrams and reference them often when you're talking or when they're asking questions</li>
        <li>Get them to explain the concept you're teaching them back to you, even if they say they get it</li>
        <li>Ask them to work on another round of edits, but to open a PR of their own this time</li>
    </ol>

    <p>Before and after the session, I point them to a couple of readings:</p>
    <ul>
        <li><a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests">GitHub Docs' Collaborate with pull requests</a>: Specifically the sections on about branches, creating/deleting branches and creating a pull request</li>
        <li><a href="https://missing.csail.mit.edu/2020/version-control/">Version Control (git)</a>, by missing semester of your CS education</li>
    </ul>

    <h3>SQL query optimization</h3>
    <p>One of the annoying problems I've been facing at work is making my SQL queries in Snowflake run more quickly. It didn't use to be a problem I thought about, because the previous pressing issue had been to make a dataset available in the first place, to get a set of dashboards up and running in the first place, speed and performance be damned.</p>
    <p>Now that those <em>are</em> up and running, having slow queries and slower dashboards are a pain.</p>
    <p>But to make any speed improvement, I must first understand query profiles.</p>
    <p>Transactional table vs operational table</p>
    </div>

</body>
</html>